# Mongoose

- [Mongoose](#mongoose)
	- [Sources](#sources)
	- [Install & Run](#install--run)
		- [Mongoose options](#mongoose-options)
	- [Basics](#basics)
		- [Schema](#schema)
		- [Model](#model)
		- [Documents](#documents)
	- [Document Querying](#document-querying)
		- [Creating](#creating)
		- [Reading](#reading)
		- [Updating](#updating)
		- [Deleting](#deleting)
		- [Indexing](#indexing)
	- [Validation and Sanitization](#validation-and-sanitization)
		- [Populate](#populate)
	- [Connection](#connection)
		- [Buffering](#buffering)
		- [Error handling](#error-handling)
	- [Subdocuments](#subdocuments)
	- [Practice](#practice)
		- [Templates](#templates)
			- [Exported function](#exported-function)
			- [My template](#my-template)

***

## Sources

1. https://mongoosejs.com/docs/ - docs
2. https://developer.mozilla.org/ru/docs/Learn/Server-side/Express_Nodejs/mongoose - MDN tutorial
3. https://stackoverflow.com/questions/38051977/what-does-populate-in-mongoose-mean - what is populate
4. https://vsvaibhav2016.medium.com/best-practice-of-mongoose-connection-with-mongodb-c470608483f0 - best practices

***


## Install & Run

```bash
# In your project folder
npm i mongoose 

# Don'e forget to run your DB server when you start working
sudo systemctl start mongodb
```

```js
const express = require('express')
const app = express()
const server = require('http').createServer(app)
const PORT = process.env.PORT || 5000

const mongoose = require('mongoose')
const { connection, Schema } = mongoose

// Connect to the DB: 27017 is the default MongoDB port, `test` - our DB name
mongoose.connect(
	'mongodb://localhost:27017/test',
	{ 
		useNewUrlParser: true, 
		useUnifiedTopology: true, 
		useFindAndModify: false 	/* removes some deprecated syntax */
	},
	(err) => {
		if (err) console.error(err)
		server.listen(PORT)
	}
)

connection.on('error', console.error.bind(console, 'connection error:'))
connection.once('open', () => {
	console.log('Connected!')
})

// Schema
const kittySchema = new Schema(
	{
		name: String
	},
	{ versionKey: false } // deleting the default `__v` field
)

// NOTE: methods must be added to the schema before compiling it with mongoose.model()
kittySchema.methods.speak = function () {
	const greeting = this.name ? `Meow name is ${this.name}` : `I don't have a name`
	console.log(greeting)
}

// Static methods
kittySchema.statics.findByName = function (name) {
	return this.find({ name: new RegExp(name, 'i') })
}

// Model - based on the Schema
const Kitten = mongoose.model('Kitten', kittySchema)

// Talkative kitten - a class instance
const fluffy = new Kitten({ name: 'Fluffy' })

// Sync with the DB
fluffy.save((err, fluffy) => {
	if (err) return console.error(err)
	fluffy.speak()
})

// findAll
Kitten.find((err, kittens) => {
	if (err) return console.error(err)
	console.log(kittens)
})

// Our static method
let animals = Kitten.findByName('Silence').then((r) => console.log(r))
```

![](img/2021-03-23-00-19-15.png)

***

### Mongoose options

We can set various [options](https://mongoosejs.com/docs/api/mongoose.html#mongoose_Mongoose-set) to our `mongoose` instance.

Some of the options you may want to use:

```js
mongoose.set('debug', true)	// debug DB queries to the console
mongoose.set('useFindAndModify', false)	// stop using deprecated findAndModify functions
mongoose.set('useCreateIndex', true)	// stop using deprecated index functions
// mongoose.set('runValidators', true)	// enforce running custom validators for all "update" queries
```

***


## Basics

### Schema

Schema describes the documents' **metadata**:

- document properties and methods
- static Model methods
- compound indexes
- middleware

Models (classes) are based on Schemas.

```js
const { Schema } = mongoose
 
const blogSchema = new Schema({
    title:  String, // Short notation
    author: {	// Long notation
			type: String,
			default: 'Anon'
		},	
    body:   String,
    comments: [{ body: String, date: Date }],
    date: {	
			type: Date, 
			default: Date.now 
		},
    hidden: Boolean,
    meta: {
			votes: Number,
      favs:  Number
			// whoLiked: [String],
    }
  })
```

***

Data types for the Schema fields:

- `String`
- `Number`
- `Date`
- `Buffer`
- `Boolean`
- `Mixed`
- `ObjectId`
- `Array`
- `Decimal128`
- `Map`

***

Methods **must** be defined in Schema before compiling it into a Model.

```js
// Instance method
kittySchema.methods.speak = function () {
	const greeting = this.name ? `Meow name is ${this.name}` : `I don't have a name`
	console.log(greeting)
}

// Static method
kittySchema.statics.findByName = function (name) {
	return this.find({ name: new RegExp(name, 'i') })
}

// Then compile into a Model
const Kitten = mongoose.model('Kitten', kittySchema)
```

***


### Model

Models are compiled from Schemas and work as **constructors for Documents**.

You should call `mongoose.model()` **after** you've added everything you wanted: hooks, methods, etc.

```js
// ... define yourSchema

// Compile it into a class constructor
const Tank = mongoose.model('Tank', yourSchema)
```

**NB**: we pass a **singular** name for the model which translates into the **plural lowecased** version of it as a collection name in the DB. "Cat" -> "cats". This behavior can be prevented. 

***


### Documents

Mongoose documents represent a one-to-one mapping to documents as stored in MongoDB. 

Each document is an instance of its Model.

Counterintuitively, `Model` class inherits from `Document`.

***


## Document Querying

All the below methods are Model [instance](https://mongoosejs.com/docs/api/model.html) methods.

Also, there're a group of `findOneAnd...` methods. They are similar to the below ones but return the modified document instead of the result codes. You need to set `useFindAndModify: false` [setting](https://stackoverflow.com/questions/52572852/deprecationwarning-collection-findandmodify-is-deprecated-use-findoneandupdate) for them to work properly.

***

### Creating

- `new Model({}).save()` - inserts or updates a document in the DB
- `Model.create ([ {}, {} ])` - a shortcut for the looped version of the previous. Each document is created, validated and if successful - inserted into the DB. Repeats for all documents.
- `Model.insertMany (arrayOfDocuments, options, cb)` - validates **all** the passed documents - if **all** of them passed the validation, sends them to the server **in one operation**. All or nothing. Also it's **faster** than `create` as it only makes 1 query to the DB.

```js
// save()
const result1 = await new User({ name: 'new user', age: '999' })
result1.save()	// Sync it with the DB

// create()
const result2 = await User.create([
	{ name: 'max', age: 20 },	// This will be inserted
	{ name: 'user', age: NaN }	// Error -> this won't be inserted
])

// insertMany()
const result = await User.insertMany([
	{ name: 'max', age: 20 },
	{ name: 'user', age: NaN }	// Error -> NOTHING will be inserted
])
```

***

### Reading

- `find (filter, projection, options, cb)` - returns one or multiple matching documents
- `findOne (filter, projection, options, cb)` - returns the first matching document

These methods return a Promise that resolves to the same result as you can get from the **callback**.

```js
// find all documents
await MyModel.find({})

// find all documents named john and at least 18
await MyModel.find({ name: 'john', age: { $gte: 18 } }).exec()

// executes, passing results to callback
MyModel.find({ name: 'john', age: { $gte: 18 } }, function (err, docs) {})

// executes, name LIKE john and only selecting the "name" and "friends" fields
await MyModel.find({ name: /john/i }, 'name friends').exec()

// passing options
await MyModel.find({ name: /john/i }, null, { skip: 10 }).exec()

// findById
await User.findById('604e73f2e559b9099b0b1c70', 'name')

// findOne
await User.findOne({ name: 'sasha' }, 'name')
```

Full example

```js
const express = require('express')
const app = express()
const server = require('http').createServer(app)
const PORT = process.env.PORT || 5000

const mongoose = require('mongoose')
const { connection, Schema } = mongoose

mongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true, useUnifiedTopology: true })

connection.on('error', console.error.bind(console, 'connection error:'))
connection.once('open', () => {
	console.log('Connected!')
})

const userSchema = new Schema(
	{
		name: String,
		age: Number,
		gender: String
	},
	{ versionKey: false }
)

const User = mongoose.model('User', userSchema)

run()

async function run() {
	try {
		const user1 = await User.find((err, users) => {
			if (err) return console.error(err)
		})
		const user2 = await User.findOne().where('age').gt(22)
		// const user3 = await User.findByName('Silence')

		console.log('user1', user1)
		console.log('user2', user2)
		// console.log('user3', user3)
	} catch (err) {
		console.error(err)
	}
}

server.listen(PORT)
```

***

### Updating

- `updateOne (filter, newDoc, options, cb)` - updates the first matched document
- `updateMany (filter, newDoc, options, cb)` - updates **all** documents that match the filter
- `replaceOne (filter, newDoc, options, cb)` - same as `updateOne` but totally replaces the existing document 
- `instance.overwrite (newDoc)` - overwrites an existing document

These methods return a Promise that resolves to the same result as you can get from the **callback**.

**Don't use an existing model instance** as a **filter**, this is not the intended usage and may result in unexpected behavior!

```js
await User.updateOne(
	{ name: 'Vlad' }, 
	{ name: 'Vladik' }, 
	{ upsert: true }
)
```

***

You can also modify a document using **vanilla JS assignments** and then `.save()` it to update in the DB.

```js
user.name = 'Maximus'
await user.save()
```

***

### Deleting

- `deleteOne (filter, options, cb)` - deletes the first matched document
- `deleteMany (filter, options, cb)` - deletes all metching documents

```js
await User.create({ name: 'Vlad', age: 20 })
await User.create({ name: 'Vlad', age: 20 })
await User.create({ name: 'Vlad', age: 20 })

const result = await User.deleteMany({ name: 'Vlad' })	
// { n: 3, ok: 1, deletedCount: 3 }
```

### Indexing

First, set up `mongoose.set('useCreateIndex', true)`

There're 2 ways to set up an index on a field:

- `index: true` in the field definition
- `yourSchema.index(yourIndexes)`


![](img/2021-03-25-23-43-19.png)

***


## Validation and Sanitization

Mongoose will perform **type conversion** trying to fit your input into the declared **type** for that field. 

You can assign validation and sanitization parameters for the Schema fields depending on their **type**:

- `Index`:
  - `index: Boolean` - whether to define an index on this property
  - `unique: Boolean` - whether to define a unique index
  - `sparse: Boolean` - sparse index
- `String`: 
  - `lowercase: Boolean` - call `toLowerCase()` on this field after the creation
  - `uppercase: Boolean`
  - `trim: Boolean`
  - `match: RegExp`
  - `maxLength: Number`
  - `minLength: Number`
  - `enum: Array` - checks if the value is in the array
  - `populate: Object`
- `Number`:
  - `max: Number`
  - `min: Number`
  - `enum: Array` - checks if the value is strictly equal to any of the values in the array
  - `populate: Object`
- `Date`:
  - `min: Date`
  - `max: Date`
- `ObjectId`:
  - `populate`

Also for any field:

- `required: any` - can accept different values, see examples below

```js
const userSchema = new Schema(
	{
		name: {
			type: String,
			uppercase: true
		},
		age: {
			type: Number,
			index: true
		}
	},
	{ versionKey: false }
)
```

```js

```

***

### Populate

Detailed explanation: https://stackoverflow.com/a/53002303/12166570

Imagine, you connected your document to another document from another collection. 

```js
Story.findOne({ title: Nintendo })

// Returns
{
	_creator : A0jfdSMmEJj9,	// _id of the creator from another collection
	title    : Nintendo,
	fans     : [r432i900fds09809n, fdsjifdsjfueu88]
 }
```

We got the `_id` of the related document. Now what if we wanted to add more data about this connected document?

```js
Story.findOne({ title: Nintendo }).populate('_creator')

// Returns
{
	_creator: {
		_id: A0jfdSMmEJj9,
		name: Sai,
		age: 100,
		stories: [fdsfdsfdsew38u, 89hr3232, ...]
	},
	title: Nintendo,
	fans: [r432i900fds09809n, fdsjifdsjfueu88]
}
```

`populate` pulled the data from another collection to our document.

But maybe we want **less** info, only some specific fields:

```js
Story.findOne({ title: Nintendo }).populate('_creator', 'name age')

// Returns
{
	_creator: {
		name: Sai,
		age: 100,
	},
	title: Nintendo,
	fans: [r432i900fds09809n, fdsjifdsjfueu88]
}
```

So, `populate` literally populates your document with data from other documents.

***


## Connection

https://docs.mongodb.com/manual/reference/connection-string/ - string format docs

```js
// Basic connection
mongoose.connect('mongodb://localhost:27017/myapp', { useNewUrlParser: true })

// More params
mongoose.connect('mongodb://username:password@host:port/database?options...', { useNewUrlParser: true })
```

***

### Buffering

Mongoose lets you start using your models immediately, without waiting for mongoose to establish a connection to MongoDB.

That's because mongoose buffers model function calls internally. 

```js
mongoose.connect('mongodb://localhost:27017/myapp', {useNewUrlParser: true})

const MyModel = mongoose.model('Test', new Schema({ name: String }))
// Works without awaiting
MyModel.findOne(function(error, result) { /* ... */ })
```

Mongoose **won't throw** if you use a model without connecting, it will just **hang** until the connection is established. If it's not re-established within `reconnectTries` and `reconnectInterval` time, then an error is finally thrown. If the connection re-established, buffered queries will be fulfilled. 

***

### Error handling

There're 2 classes of errors with the connection:

- **Initial connection** error emits `error` but **doesn't** reconnect automatically
- Error **after** initial connection was established emits `error` and **tries to reconnect**.

Basically, you listen for those errors on your `connection` and react accordingly. See examples below.

***


## Subdocuments

Documents embedded in other documents. In mongoose this means nested Schemas.

Nested schemas can have middleware, custom validation logic, virtuals, and any other feature top-level schemas can use. The major difference is that subdocuments are not saved individually, **they are saved whenever their top-level parent document is saved**.

```js
const childSchema = new Schema({ name: 'string' })

const parentSchema = new Schema({
	children: [childSchema],	// array of subdocuments
	child: childSchema,		// single nested subdocument
})

const Parent = mongoose.model('Parent', parentSchema)

const parent = new Parent({ children: [{ name: 'Matt' }, { name: 'Sarah' }] })
parent.children[0].name = 'Matthew'

// `parent.children[0].save()` is a no-op. You need to save the parent document!
parent.save()
```

CRUD operatons:

```js
// Creating

// Reading

// Updating

// Deleting
```

***


## Practice

### Templates

#### Exported function

Based on [this](https://vsvaibhav2016.medium.com/best-practice-of-mongoose-connection-with-mongodb-c470608483f0) article.

Consider this snippet when you're building your app.

```js
//require mongoose module
var mongoose = require('mongoose')

//require chalk module to give colors to console text
var chalk = require('chalk')

//require database URL from properties file
var dbURL = require('./property').db

var connected = chalk.bold.cyan
var error = chalk.bold.yellow
var disconnected = chalk.bold.red
var termination = chalk.bold.magenta

//export this function and imported by server.js
module.exports = function () {
	mongoose.connect(dbURL)

	mongoose.connection.on('connected', function () {
		console.log(connected('Mongoose default connection is open to ', dbURL))
	})

	mongoose.connection.on('error', function (err) {
		console.log(error('Mongoose default connection has occured ' + err + ' error'))
	})

	mongoose.connection.on('disconnected', function () {
		console.log(disconnected('Mongoose default connection is disconnected'))
	})

	process.on('SIGINT', function () {
		mongoose.connection.close(function () {
			console.log(termination('Mongoose default connection is disconnected due to application termination'))
			process.exit(0)
		})
	})
}
```

#### My template

```js
const express = require('express')
const app = express()
const server = require('http').createServer(app)
const PORT = process.env.PORT || 5000

const mongoose = require('mongoose')
const { runInContext } = require('vm')
const { connection, Schema } = mongoose

mongoose.set('debug', true)
mongoose.set('useFindAndModify', false)
mongoose.set('useCreateIndex', true)

const dbURI = 'mongodb://localhost:27017/test'
const connectionOptions = {
	useNewUrlParser: true,
	useUnifiedTopology: true
}

connection.on('connecting', () => {
	console.log('Connecting to MongoDB...')
})
connection.on('connected', () => {
	console.log('MongoDB connected!')
})
connection.once('open', () => {
	console.log('MongoDB connection opened!')
})
connection.on('reconnected', () => {
	console.log('MongoDB reconnected!')
})
connection.on('disconnected', () => {
	console.log('MongoDB disconnected!')
	tryConnectingToDB()
})
connection.on('error', (error) => {
	console.error('Error in MongoDb connection: ' + error)
	mongoose.disconnect()
})

process.on('SIGINT', () => {
	mongoose.connection.close(function () {
		console.log('Mongoose default connection is disconnected due to application termination')
		process.exit(0)
	})
})

tryConnectingToDB()

function tryConnectingToDB() {
	try {
		mongoose.connect(dbURI, connectionOptions, (err) => {
			if (err) console.error(err)
			server.listen(PORT)
		})
	} catch (err) {
		console.log(err)
	}
}
```