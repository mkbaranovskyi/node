# Mongoose

- [Mongoose](#mongoose)
	- [Sources](#sources)
	- [Install & Run](#install--run)
		- [Mongoose options](#mongoose-options)
	- [Basics](#basics)
		- [Schema](#schema)
		- [Model](#model)
		- [Documents](#documents)
	- [Document Querying](#document-querying)
		- [Creating](#creating)
		- [Reading](#reading)
		- [Updating](#updating)
		- [Deleting](#deleting)
		- [Indexing](#indexing)
	- [Validation and Sanitization](#validation-and-sanitization)
		- [Populate](#populate)
	- [Transactions](#transactions)

***

## Sources

1. https://mongoosejs.com/docs/ - docs
2. https://stackoverflow.com/questions/38051977/what-does-populate-in-mongoose-mean - what is populate

***


## Install & Run

```bash
# In your project folder
npm i mongoose 

# Don'e forget to run your DB server when you start working
sudo systemctl start mongodb
```

```js
const express = require('express')
const app = express()
const server = require('http').createServer(app)
const PORT = process.env.PORT || 5000

const mongoose = require('mongoose')
const { connection, Schema } = mongoose

// Connect to the DB: 27017 is the default MongoDB port, `test` - our DB name
mongoose.connect(
	'mongodb://localhost:27017/test',
	{ 
		useNewUrlParser: true, 
		useUnifiedTopology: true, 
		useFindAndModify: false 	/* removes some deprecated syntax */
	},
	(err) => {
		if (err) console.error(err)
		server.listen(PORT)
	}
)

connection.on('error', console.error.bind(console, 'connection error:'))
connection.once('open', () => {
	console.log('Connected!')
})

// Schema
const kittySchema = new Schema(
	{
		name: String
	},
	{ versionKey: false } // deleting the default `__v` field
)

// NOTE: methods must be added to the schema before compiling it with mongoose.model()
kittySchema.methods.speak = function () {
	const greeting = this.name ? `Meow name is ${this.name}` : `I don't have a name`
	console.log(greeting)
}

// Static methods
kittySchema.statics.findByName = function (name) {
	return this.find({ name: new RegExp(name, 'i') })
}

// Model - based on the Schema
const Kitten = mongoose.model('Kitten', kittySchema)

// Talkative kitten - a class instance
const fluffy = new Kitten({ name: 'Fluffy' })

// Sync with the DB
fluffy.save((err, fluffy) => {
	if (err) return console.error(err)
	fluffy.speak()
})

// findAll
Kitten.find((err, kittens) => {
	if (err) return console.error(err)
	console.log(kittens)
})

// Our static method
let animals = Kitten.findByName('Silence').then((r) => console.log(r))
```

![](img/2021-03-23-00-19-15.png)

***

### Mongoose options

We can set various [options](https://mongoosejs.com/docs/api/mongoose.html#mongoose_Mongoose-set) to our `mongoose` instance.

Some of the options you may want to use:

```js
mongoose.set('debug', true)	// debug DB queries to the console
mongoose.set('useFindAndModify', false)	// stop using deprecated findAndModify functions
mongoose.set('useCreateIndex', true)	// stop using deprecated index functions
// mongoose.set('runValidators', true)	// enforce running custom validators for all "update" queries
```

***


## Basics

### Schema

Schema describes the documents' **metadata**:

- document properties and methods
- static Model methods
- compound indexes
- middleware

Models (classes) are based on Schemas.

```js
const { Schema } = mongoose
 
const blogSchema = new Schema({
    title:  String, // Short notation
    author: {	// Long notation
			type: String,
			default: 'Anon'
		},	
    body:   String,
    comments: [{ body: String, date: Date }],
    date: {	
			type: Date, 
			default: Date.now 
		},
    hidden: Boolean,
    meta: {
			votes: Number,
      favs:  Number
			// whoLiked: [String],
    }
  })
```

***

Data types for the Schema fields:

- `String`
- `Number`
- `Date`
- `Buffer`
- `Boolean`
- `Mixed`
- `ObjectId`
- `Array`
- `Decimal128`
- `Map`

***

Methods **must** be defined in Schema before compiling it into a Model.

```js
// Instance method
kittySchema.methods.speak = function () {
	const greeting = this.name ? `Meow name is ${this.name}` : `I don't have a name`
	console.log(greeting)
}

// Static method
kittySchema.statics.findByName = function (name) {
	return this.find({ name: new RegExp(name, 'i') })
}

// Then compile into a Model
const Kitten = mongoose.model('Kitten', kittySchema)
```

***


### Model

Models are compiled from Schemas and work as **constructors for Documents**.

You should call `mongoose.model()` **after** you've added everything you wanted: hooks, methods, etc.

```js
// ... define yourSchema

// Compile it into a class constructor
const Tank = mongoose.model('Tank', yourSchema)
```

**NB**: we pass a **singular** name for the model which translates into the **plural lowecased** version of it as a collection name in the DB. "Cat" -> "cats". This behavior can be prevented. 

***


### Documents

Mongoose documents represent a one-to-one mapping to documents as stored in MongoDB. 

Each document is an instance of its Model.

Counterintuitively, `Model` class inherits from `Document`.

***


## Document Querying

All the below methods are Model [instance](https://mongoosejs.com/docs/api/model.html) methods.

Also, there're a group of `findOneAnd...` methods. They are similar to the below ones but return the modified document instead of the result codes. You need to set `useFindAndModify: false` [setting](https://stackoverflow.com/questions/52572852/deprecationwarning-collection-findandmodify-is-deprecated-use-findoneandupdate) for them to work properly.

***

### Creating

- `instance.save (options)` - inserts or updates a document in the DB
- `Model.create ([ {}, {} ])` - a shortcut for the looped version of `new Model({}).save()`. Each document is created, validated and if successful - inserted into the DB. Repeats for all documents.
- `Model.insertMany (arrayOfDocuments, options, cb)` - validates **all** the passed documents - if **all** of them passed the validation, sends them to the server **in one operation**. All or nothing. Also it's **faster** than `create` as it only makes 1 query to the DB.

```js
// save()
const result1 = await new User({ name: 'new user', age: '999' })
result1.save()	// Sync it with the DB

// create()
const result2 = await User.create([
	{ name: 'max', age: 20 },	// This will be inserted
	{ name: 'user', age: NaN }	// Error -> this won't be inserted
])

// insertMany()
const result = await User.insertMany([
	{ name: 'max', age: 20 },
	{ name: 'user', age: NaN }	// Error -> NOTHING will be inserted
])
```

***

### Reading

- `find (filter, projection, options, cb)` - returns one or multiple matching documents
- `findOne (filter, projection, options, cb)` - returns the first matching document

These methods return a Promise that resolves to the same result as you can get from the **callback**.

```js
// find all documents
await MyModel.find({})

// find all documents named john and at least 18
await MyModel.find({ name: 'john', age: { $gte: 18 } }).exec()

// executes, passing results to callback
MyModel.find({ name: 'john', age: { $gte: 18 } }, function (err, docs) {})

// executes, name LIKE john and only selecting the "name" and "friends" fields
await MyModel.find({ name: /john/i }, 'name friends').exec()

// passing options
await MyModel.find({ name: /john/i }, null, { skip: 10 }).exec()

// findById
await User.findById('604e73f2e559b9099b0b1c70', 'name')

// findOne
await User.findOne({ name: 'sasha' }, 'name')
```

Full example

```js
const express = require('express')
const app = express()
const server = require('http').createServer(app)
const PORT = process.env.PORT || 5000

const mongoose = require('mongoose')
const { connection, Schema } = mongoose

mongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true, useUnifiedTopology: true })

connection.on('error', console.error.bind(console, 'connection error:'))
connection.once('open', () => {
	console.log('Connected!')
})

const userSchema = new Schema(
	{
		name: String,
		age: Number,
		gender: String
	},
	{ versionKey: false }
)

const User = mongoose.model('User', userSchema)

run()

async function run() {
	try {
		const user1 = await User.find((err, users) => {
			if (err) return console.error(err)
		})
		const user2 = await User.findOne().where('age').gt(22)
		// const user3 = await User.findByName('Silence')

		console.log('user1', user1)
		console.log('user2', user2)
		// console.log('user3', user3)
	} catch (err) {
		console.error(err)
	}
}

server.listen(PORT)
```

***

### Updating

- `updateOne (filter, newDoc, options, cb)` - updates the first matched document
- `replaceOne (filter, newDoc, options, cb)` - same as `updateOne` but totally replaces the existing document 
- `updateMany (filter, newDoc, options, cb)` - updates **all** documents that match the filter

These methods return a Promise that resolves to the same result as you can get from the **callback**.

**Don't use an existing model instance** as a **filter**, this is not the intended usage and may result in unexpected behavior!

```js
await User.updateOne(
	{ name: 'Vlad' }, 
	{ name: 'Vladik' }, 
	{ upsert: true }
)
```

***

### Deleting

- `deleteOne (filter, options, cb)` - deletes the first matched document
- `deleteMany (filter, options, cb)` - deletes all metching documents

```js
await User.create({ name: 'Vlad', age: 20 })
await User.create({ name: 'Vlad', age: 20 })
await User.create({ name: 'Vlad', age: 20 })

const result = await User.deleteMany({ name: 'Vlad' })	
// { n: 3, ok: 1, deletedCount: 3 }
```

### Indexing

First, set up `mongoose.set('useCreateIndex', true)`

There're 2 ways to set up an index on a field:

- `index: true` in the field definition
- `yourSchema.index(yourIndexes)`


![](img/2021-03-25-23-43-19.png)

***


## Validation and Sanitization

Mongoose will perform **type conversion** trying to fit your input into the declared **type** for that field. 

You can assign validation and sanitization parameters for the Schema fields depending on their **type**:

- `Index`:
  - `index: Boolean` - whether to define an index on this property
  - `unique: Boolean` - whether to define a unique index
  - `sparse: Boolean` - sparse index
- `String`: 
  - `lowercase: Boolean` - call `toLowerCase()` on this field after the creation
  - `uppercase: Boolean`
  - `trim: Boolean`
  - `match: RegExp`
  - `maxLength: Number`
  - `minLength: Number`
  - `enum: Array` - checks if the value is in the array
  - `populate: Object`
- `Number`:
  - `max: Number`
  - `min: Number`
  - `enum: Array` - checks if the value is strictly equal to any of the values in the array
  - `populate: Object`
- `Date`:
  - `min: Date`
  - `max: Date`
- `ObjectId`:
  - `populate`

```js
const userSchema = new Schema(
	{
		name: {
			type: String,
			uppercase: true
		},
		age: {
			type: Number,
			index: true
		}
	},
	{ versionKey: false }
)
```

***

### Populate

Detailed explanation: https://stackoverflow.com/a/53002303/12166570

Imagine, you connected your document to another document from another collection. 

```js
Story.findOne({ title: Nintendo })

// Returns
{
	_creator : A0jfdSMmEJj9,	// _id of the creator from another collection
	title    : Nintendo,
	fans     : [r432i900fds09809n, fdsjifdsjfueu88]
 }
```

We got the `_id` of the related document. Now what if we wanted to add more data about this connected document?

```js
Story.findOne({ title: Nintendo }).populate('_creator')

// Returns
{
	_creator: {
		_id: A0jfdSMmEJj9,
		name: Sai,
		age: 100,
		stories: [fdsfdsfdsew38u, 89hr3232, ...]
	},
	title: Nintendo,
	fans: [r432i900fds09809n, fdsjifdsjfueu88]
}
```

`populate` pulled the data from another collection to our document.

But maybe we want **less** info, only some specific fields:

```js
Story.findOne({ title: Nintendo }).populate('_creator', 'name age')

// Returns
{
	_creator: {
		name: Sai,
		age: 100,
	},
	title: Nintendo,
	fans: [r432i900fds09809n, fdsjifdsjfueu88]
}
```

So, `populate` literally populates your document with data from other documents.

***


## Transactions

Execute multiple operations in isolation and undo all the operations if one of them fails.

