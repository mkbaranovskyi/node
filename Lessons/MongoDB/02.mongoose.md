# Mongoose

- [Mongoose](#mongoose)
	- [Sources](#sources)
	- [Install & Run](#install--run)
	- [Basics](#basics)
		- [Schema](#schema)
		- [Model](#model)
			- [Intro](#intro)
			- [Querying and interacting with documents](#querying-and-interacting-with-documents)
		- [Documents](#documents)
	- [Document Querying](#document-querying)
		- [Creating](#creating)
		- [Reading](#reading)
		- [Updating](#updating)
		- [Deleting](#deleting)

***

## Sources

1. https://mongoosejs.com/docs/ - docs

***


## Install & Run

```bash
# In your project folder
npm i mongoose 

# Don'e forget to run your DB server when you start working
sudo systemctl start mongodb
```

```js
const express = require('express')
const app = express()
const server = require('http').createServer(app)
const PORT = process.env.PORT || 5000

const mongoose = require('mongoose')
const { connection, Schema } = mongoose

// Connect to the DB - 27017 is the default MongoDB port
mongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true, useUnifiedTopology: true })

connection.on('error', console.error.bind(console, 'connection error:'))
connection.once('open', () => {
	console.log('Connected!')
})

// Schema
const kittySchema = new Schema(
	{
		name: String
	},
	{ versionKey: false } // deleting the default `__v` field
)

// NOTE: methods must be added to the schema before compiling it with mongoose.model()
kittySchema.methods.speak = function () {
	const greeting = this.name ? `Meow name is ${this.name}` : `I don't have a name`
	console.log(greeting)
}

// Static methods
kittySchema.statics.findByName = function (name) {
	return this.find({ name: new RegExp(name, 'i') })
}

// Model - based on the Schema
const Kitten = mongoose.model('Kitten', kittySchema)

// Talkative kitten - a class instance
const fluffy = new Kitten({ name: 'Fluffy' })

// Sync with the DB
fluffy.save((err, fluffy) => {
	if (err) return console.error(err)
	fluffy.speak()
})

// findAll
Kitten.find((err, kittens) => {
	if (err) return console.error(err)
	console.log(kittens)
})

// Our static method
let animals = Kitten.findByName('Silence').then((r) => console.log(r))

server.listen(PORT)
```

![](img/2021-03-23-00-19-15.png)

***


## Basics

### Schema

Schema describes the documents' **metadata**:

- document properties and methods
- static Model methods
- compound indexes
- middleware

Models (classes) are based on Schemas.

```js
const { Schema } = mongoose
 
const blogSchema = new Schema({
    title:  String, // Short notation
    author: {	// Long notation
			type: String,
			default: 'Anon'
		},	
    body:   String,
    comments: [{ body: String, date: Date }],
    date: {	
			type: Date, 
			default: Date.now 
		},
    hidden: Boolean,
    meta: {
			votes: Number,
      favs:  Number
			// whoLiked: [String],
    }
  })
```

Data types for the Schema fields:

- `String`
- `Number`
- `Date`
- `Buffer`
- `Boolean`
- `Mixed`
- `ObjectId`
- `Array`
- `Decimal128`
- `Map`

Validation parameters for the Schema fields:

- `default` - default value
- `retuired` - boolean
- `unique` - boolean
- `max`, `min` - for Number
- `maxlength`, `minlength` - for String
- `enum` - field value should be a string value from the array
- `match` - regexp

***

Methods **must** be defined in Schema before compiling it into a Model.

```js
// Instance method
kittySchema.methods.speak = function () {
	const greeting = this.name ? `Meow name is ${this.name}` : `I don't have a name`
	console.log(greeting)
}

// Static method
kittySchema.statics.findByName = function (name) {
	return this.find({ name: new RegExp(name, 'i') })
}

// Then compile into a Model
const Kitten = mongoose.model('Kitten', kittySchema)
```

***


### Model

#### Intro

Models are compiled from Schemas and work as **constructors for Documents**.

You should call `mongoose.model()` **after** you've added everything you wanted: hooks, methods, etc.

```js
const Tank = mongoose.model('Tank', yourSchema)

const small = new Tank({ size: 'small' })
small.save(function (err) {
	if (err) return handleError(err)
	// saved!
})

// or

Tank.create({ size: 'small' }, function (err, small) {
	if (err) return handleError(err)
	// saved!
})

// or, for inserting large batches of documents
Tank.insertMany([{ size: 'small' }], function (err) {})
```

**NB**: we pass a **singular** name for the model which translates into the **plural lowecased** version of it as a collection name in the DB. "Cat" -> "cats"

***

#### Querying and interacting with documents

You can query documents using:

- `find` (findMany)
- `findOne`
- `findById`
- `where`

```js
const express = require('express')
const app = express()
const server = require('http').createServer(app)
const PORT = process.env.PORT || 5000

const mongoose = require('mongoose')
const { connection, Schema } = mongoose

mongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true, useUnifiedTopology: true })

connection.on('error', console.error.bind(console, 'connection error:'))
connection.once('open', () => {
	console.log('Connected!')
})

const userSchema = new Schema(
	{
		name: String,
		age: Number,
		gender: String
	},
	{ versionKey: false }
)

const User = mongoose.model('User', userSchema)

run()

async function run() {
	try {
		const user1 = await User.find((err, users) => {
			if (err) return console.error(err)
		})
		const user2 = await User.findOne().where('age').gt(22)
		// const user3 = await User.findByName('Silence')

		console.log('user1', user1)
		console.log('user2', user2)
		// console.log('user3', user3)
	} catch (err) {
		console.error(err)
	}
}

server.listen(PORT)
```

***


### Documents

Mongoose documents represent a one-to-one mapping to documents as stored in MongoDB. 

Each document is an instance of its Model.

Counterintuitively, `Model` class inherits from `Document`.

***


## Document Querying

All these methods are Model [instance](https://mongoosejs.com/docs/api/model.html) methods.

### Creating

- `instance.save (options)` - inserts or updates a document in the DB
- `Model.create ([ {}, {} ])` - validates one document and inserts it into the DB if it passed the validation, then repeats for all documents. So partial insertion are possible.
- `Model.insertMany (arrayOfDocuments, options, cb)` - validates **all** the passed documents - if **all** of them passed the validation, sends them to the server **in one operation**. So all or nothing. Also it's **faster** than `create` as it only makes 1 query to the DB.

```js
// save()
const result1 = await new User({ name: 'new user', age: '999' })
result1.save()	// Sync it with the DB

// create()
const result2 = await User.create([
	{ name: 'max', age: 20 },	// This will be inserted
	{ name: 'user', age: NaN }	// Error -> this won't be inserted
])

// insertMany()
const result = await User.insertMany([
	{ name: 'max', age: 20 },
	{ name: 'user', age: NaN }	// Error -> NOTHING will be inserted
])
```

***

### Reading

- `find (filter, projection, options, cb)` - main query tool
- `findById (id, projection, options, cb)` - returns 1 match
- `findOne (filter, projection, options, cb)`

Callback looks like this: `(err, result) => {}`

```js
// find all documents
await MyModel.find({})

// find all documents named john and at least 18
await MyModel.find({ name: 'john', age: { $gte: 18 } }).exec()

// executes, passing results to callback
MyModel.find({ name: 'john', age: { $gte: 18 } }, function (err, docs) {})

// executes, name LIKE john and only selecting the "name" and "friends" fields
await MyModel.find({ name: /john/i }, 'name friends').exec()

// passing options
await MyModel.find({ name: /john/i }, null, { skip: 10 }).exec()

// findById
await User.findById('604e73f2e559b9099b0b1c70', 'name')

// findOne
await User.findOne({ name: 'sasha' }, 'name')
```

***

### Updating

- `updateOne ()` - 
- `updateMany ()` - 

```js

```

***

### Deleting

