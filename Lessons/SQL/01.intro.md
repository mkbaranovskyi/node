# SQL Intro

- [SQL Intro](#sql-intro)
	- [Sources](#sources)
	- [Installation and Running](#installation-and-running)
	- [Theory](#theory)
		- [Connections](#connections)
		- [Terms](#terms)
		- [Data Types](#data-types)
		- [Indices](#indices)

***

## Sources

1. https://medium.com/@rshrc/mysql-on-manjaro-973e4bfc4f05
2. gitgod:
   1. http://gitlab.a-level.com.ua/gitgod/PHP/src/master/ER-SQL.md
   2. http://gitlab.a-level.com.ua/gitgod/PHP/src/master/SQL.md
   3. http://gitlab.a-level.com.ua/gitgod/PHP/src/master/SQLHomeWork.md
3. http://2sql.ru - nice tutorial
4. https://www.w3schools.com/sql/
5. https://dev.mysql.com/doc/refman/8.0/en/
6. https://www.sqltutorial.org
7. https://mariadb.com/kb/en/auto_increment/
8. https://www.techonthenet.com/mysql/tables/alter_table.php#:~:text=The%20syntax%20to%20drop%20a,of%20the%20table%20to%20modify.


***


## Installation and Running

Open the Terminal and run these commands:

1. `sudo pacman -S mysql` or `sudo pacman -S mariadb`
2. Pick the 1st option if you are promped to choose.
3. `sudo systemctl start mysqld`
4. If you got an error, type this: `sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql`
5. `sudo systemctl start mysqld && sudo mysql_secure_installation`
6. You will be prompted to answer a few questions about whether to delete the default database or leave it be, and some others similar. 
7. Run `mysql -u root -p`. Enter the password you've chosen during the installation. 

To run it the other day you should:

1. enable the SQL server: `sudo systemctl start mysqld`
2. enter the database: `mysql -u root -p`

***


## Theory 

MySQL is a **relational** (because data is stored in tables that are related to each other) database system. 

### Connections

- One to One (rare)
- One to Many (often): one post and many comments to it
- Many to Many: many posta and many tags

To handle "Many to Many" connection, we need an extra table.

***


### Terms

- **data value** - single value
- **record** - a **row** of data values
- **field** - a **column** of data values
- **entity** - a set of meaningful data (row, column, table, etc.)

![](img/2020-10-10-15-44-45.png)

***


### Data Types

Since databases are intent to store huge amounts of data, there are many types of data that you can use to store just the amount of data you need (and no more!).

**Numeric**

| Type                                     | Description                                                                                                                                                        | Bytes  |
| ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------ |
| `TINYINT`                                | `-128` to `127`                                                                                                                                                    | 1      |
| `SMALLINT`                               | `-32768` to `32767`                                                                                                                                                | 2      |
| `MEDIUMINT`                              | `-8388608` to `8388607`                                                                                                                                            | 3      |
| `INT`                                    | `-2147483648` to `2147483647`                                                                                                                                      | 4      |
| `BIDINT`                                 | `-9223372036854775808` to `9223372036854775807`                                                                                                                    | 8      |
| `FLOAT(p)`                               | Floating point number. Effective for mathematical calculations. If precision `p` is 0-24 - the data type is 4-byte `FLOAT`, if `p` is 25-53 - 8-byte `DOUBLE`      | 4, 8   |
| `DECIMAL(digits, decimals)` == `NUMERIC` | Fixed point number, effective for calculations where the maximum precision is needed (e.g. with money). `DECIMAL(5,2)` can store values from `-999.99` to `999.99` | Varies |

Any of the described types can be **unsigned** if you add the word: `TINYINT UNSIGNED`: 

***

**Boolean**

Boolean as a type only exists in *PostgreSQL*. In MySQL or SQL Server use `BIT` or `BOOLEAN` (which is an alias for `TINYINT`) instead.

***

**String**

| Type                     | Description                                                                                                                                                                                                                             | Bytes               |
| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- |
| `CHAR(size: 0-255)`      | Fixed-length string, size is the max characters stored. `CHAR(30)` stores up to 30 characters. Trailing spaces are **removed** (you write `'ab '` and retreive `'ab'`).                                                                 | size (<= 256 bytes) |
| `VARCHAR(size: 0-65535)` | Variable-length string. Can store 1- and 2-byte characters (specified by the **prefix** which takes 1 or 2 bytes). `65535` is the max length of **sum** of the all VARCHAR values in the `record`. Trailing spaces are **not** removed. | Varies              |

This is how it works in **non-strict** mode:

![](img/2020-10-11-13-35-54.png)

In **strict** mode, there will be an **error** because of the exceeding length. 

`VARCHAR` is more effective **memory-wise** but `CHAR` is more effective **speed-wise**. 

***

Text: 

| Type         | Max size   |
| ------------ | ---------- |
| `TINYTEXT`   | 255 bytes  |
| `TEXT`       | 65 kB      |
| `MEDIUMTEXT` | 16 MD	    |
| `LONGTEXT`   | 4 GB			  |

Text types are needed for storing **big** amounts of data. Also, **full-text search** is possible for these types. 

***

Date and time:

| Type          | Description                                                                            |
| ------------- | -------------------------------------------------------------------------------------- |
| `DATE`        | YYYY-MM-DD                                                                             |
| `TIME`        | HH:MM:SS                                                                               |
| `DATETIME`    | YYYY-MM-DD HH:MM:SS                                                                    |
| `TIMESTAMP`   | DATETIME that gets **automatically** filled and **updated** when the record if changed |
| `YEAR(2 | 4)` | Year in 2- or 4-digit format (use 4)                                                   |

***

Other types:

| Type   | Description |
| ------ | ----------- |
| `JSON` |

***


### Indices

Databases store huge amounts of data, so sorting it would be madness. Instead, it has lists of **indices** or **links** related to **records**. And these indices can be sorted easily. 

**Unsorted** search in 1000 records would take up to 1000 comparisons (computational complexity `O(n)`). 

**Sorted** arrays of data can be searched with a **binary search** (`O(log2(n))`). We'll need 10 comparisons to find data among 1000 records, 11 - for 2000, etc.

Indices can be created at any moment, not just at the table creation. 

***



