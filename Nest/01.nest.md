# Nest
- [Nest](#nest)
  - [Links](#links)
  - [Intro](#intro)
    - [Install & Run](#install--run)
  - [Entities](#entities)
    - [Modules](#modules)
      - [Intro](#intro-1)
      - [Global modules](#global-modules)
      - [Dynamic modules](#dynamic-modules)
    - [Providers](#providers)
      - [`useClass`](#useclass)
      - [`useValue`](#usevalue)
      - [`useFactory`](#usefactory)
      - [`useExisting`](#useexisting)
    - [Controllers](#controllers)
    - [Scope](#scope)

***

## Links

- [Video tutorial](https://youtu.be/abdgy72csaA)

***

## Intro

### Install & Run

```bash
npm i -g @nestjs/cli

nest new test
```

You can generate entities:

```bash
# Help
nest generate --help

# Controller
nest generate controller products
nest g co products

# Services
nest g s products
```

***


## Entities

- **Modules**
  - `nest g mo module_name`
  - wrapped in `@Module()` wrapper
  - contain metadata that is used to organize the app structure
  - connect controllers and services to each other and other modules
- **Controllers**
  - `nest g co controller_name`
  - wrapped in `@Controller()` wrapper
  - manage routing and set certain parameters
  - call Services to handle requests
- **Services** 
  - `nest g s service_name`
  - wrapped in `@Injectable()` wrapper
  - store all the logic
  - if you want to use them in other modules, you need to **inject** them in the `constructor` (see further)

Example of a typical feature structure:

![](img/2021-10-02-20-12-35.png)

***

### Modules

#### Intro

`@Module({})` decorator takes a single object whose properties descibe the module:

- `imports` - an array of Modules that you import. Their providers (Services) will be automatically available in the current module once you **inject** them in Services.
- `controllers` - Controller(-s) of the current module (if any)
- `providers` - Services of the current module. Services of other modules that you already mentioned in `imports` are already available - no need to mention them here.
- `exports` - providers (Services) of this Module that should be available (public) in other modules that import this Module. 

Modules are **singletons** by default, so the same instance can be shared between modules effortlessly.

Example `cats.module`:

```ts
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  imports: [
    ConfigModule,
    JwtModule,
  ]
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService]
})
export class CatsModule {}
```

Now every module that imported `CatsModule`, has access to `CatsService`. 

***

#### Global modules

You need to import them in the `app.module` once, and they will be accessible throughout the app:

- either `@Global` decorator for regular Modules
- or `global: true` field in dynamic Modules

```ts
@Global
@Module({
  controllers: [MyModuleController],
  providers: [MyModuleService],
  exports: [MyModuleService],
})
export class MyModule {}
```

***

#### Dynamic modules

Classes that have **static methods** that return the same object with `providers`, `exports`, etc. 

By convention, methods are often called: 

- `forRoot` - global ones
- `forFeature` - local ones

```ts
// database.module
import { Module, DynamicModule } from '@nestjs/common';
import { createDatabaseProviders } from './database.providers';
import { Connection } from './connection.provider';

@Module({
  providers: [Connection],
})
export class DatabaseModule {
  static forRoot(entities = [], options?): DynamicModule {
    const providers = createDatabaseProviders(options, entities);
    return {
      module: DatabaseModule,
      providers: providers,
      exports: providers,
    };
  }
}

// app.module
@Module({
  imports: [
    DatabaseModule.forRoot([UserEntity]),
  ]
})
```

***

### Providers

Providers are plain JavaScript classes that are declared as providers in a module.

In practice, these are Services, Factories, Repositories etc. that can be injected. 

There're 4 types of them (F12 to `providers` and then `Provider` to see all of them):

- `useClass`
- `useFactory`
- `useValue`
- `useExisting` - use the existing provider under an alias

#### `useClass`

This notation

```ts
@Module({
  providers: [AppService],
})
export class AppModule {}
```

... is a full equivalent of this

```ts
@Module({
  providers: [{
    provide: AppService,
    useClass: AppService,
  }],
})
export class AppModule {}
```

#### `useValue`

Can be useful for mocking:

Try changing this

```ts
@Module({
  controllers: [ProductsController],
  providers: [ProductsService],
})
export class ProductsModule {}
```

... to this: 

```ts
@Module({
  controllers: [ProductsController],
  providers: [{
    provide: ProductsService,
    useValue: {
      getAll() {
        return 'mocked getAll';
      }
    },
  }],
})
export class ProductsModule {}
```

#### `useFactory`

Useful when we want to provide a service with some arguments attached (e.g. configs).

```ts
providers: [
  {
    useFactory: (configService: ConfigService) => { // The factory function that should return an instance of a Service or other provider
      const sendGridOptions = configService.get<ISendgridOptions>('sendgrid');
      if (!sendGridOptions) {
        throw new Error("Couldn't load Sendgrid configs");
      }
      return new SendGridService(sendGridOptions);
    },
    provide: SendGridService, // The name of the provider that will be used in the outside world
    inject: [ConfigService],  // Arguments for the factory function above
  },
],
```

#### `useExisting`

Provides new name for an existing Provider.

```ts
provider: [{
  provide: 'SecondServiceName',
  useExisting: ProductsService,
}]
```

***

### Controllers

You need to **inject** Providers (Services) into the `constructor` of your controllers. 

Nest uses **types** (or alternatively - strings and Symbols) to recognize what to inject. 

```ts
@Controller('products')
export class ProductsController {
  constructor(
    private readonly productsService: ProductsService,  // type says Nest what to inject
  ) { }

  // ...
}
```

Alternatively, you can use **strings**:

```ts
@Module({
  controllers: [ProductController],
  providers: [{
    provide: 'products-service',
    useClass: ProductsService,
  }],
})
export class ProductsModule {}
```

```ts
@Controller('products')
export class ProductsController {
  constructor(
    @Inject('products-service') private productsService: any, // any works now because Nest uses the string to recognize the service
  ) { }

  // ...
}
```

***

### Scope

Nest has 3 [scopes](https://docs.nestjs.com/fundamentals/injection-scopes#injection-scopes):

- `DEFAULT` - Singleton. A single instance of the provider is shared across the entire application. All singleton providers are instantiated once the app bootstraps. 
- `REQUEST` - A new instance of the provider is created exclusively for each incoming request. The instance is garbage-collected after the request has completed processing.
- `TRANSIENT` - Each consumer that injects a transient provider will receive a new, dedicated instance.

**Local storage** is a good example of when to use a different Scope: each user needs to use its own instance of it, local storage should not be shared among all users. 

Another good example is a **chainable class**. It should be `REQUEST` to not create conflicts during chaining when different users send their requests. 

```ts
import { Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class LocalStorageService {}
```

And for custom providers:

```ts
{
  provide: 'CACHE_MANAGER',
  useClass: CacheManager,
  scope: Scope.TRANSIENT,
}
```

When you apply Scope to a Controller, you actually apply it all its handler methods. 

```ts
@Controller({
  path: 'cats',
  scope: Scope.REQUEST,
})
export class CatsController {}
```

***

Imagine the following dependency graph: `CatsController <- CatsService <- CatsRepository`.

If `CatsService` is defined as `REQUEST`-scoped, `CatsController` that depends on it, will also become one. `CatsRepository` will remain `DEFAULT` as it doesn't depend on Services that use it. 

***




