# Nest
- [Nest](#nest)
  - [Links](#links)
  - [Related theory](#related-theory)
    - [Inversion of control and Dependency injection](#inversion-of-control-and-dependency-injection)
  - [Intro](#intro)
    - [Install & Run](#install--run)
  - [Entities](#entities)
    - [Modules](#modules)
      - [Intro](#intro-1)
      - [Global modules](#global-modules)
      - [Dynamic modules](#dynamic-modules)
    - [Providers](#providers)
      - [`useClass`](#useclass)
      - [`useValue`](#usevalue)
      - [`useFactory`](#usefactory)
      - [`useExisting`](#useexisting)
    - [Controllers](#controllers)
    - [Scope](#scope)
  - [Other concepts](#other-concepts)
    - [DTO](#dto)
    - [Pipes](#pipes)
      - [Intro](#intro-2)
      - [Binding pipes](#binding-pipes)
      - [Custom pipes](#custom-pipes)
  - [Middleware](#middleware)

***

## Links

- [Video tutorial](https://youtu.be/abdgy72csaA)

***

## Related theory

### Inversion of control and Dependency injection

1. [Video](https://youtu.be/EPv9-cHEmQw)
2. [Good explanation](https://stackoverflow.com/a/3108/12166570)


**Inversion of control** (IOC) to create instances of dependencies first and latter instance of a class (optionally injecting them through constructor). Instead of creating an instance of the class first and then the class instance creating instances of dependencies. 

Thus, inversion of control inverts the flow of control of the program. Instead of the callee controlling the flow of control (while creating dependencies), the caller controls it.

This is what `D` in `SOLID` is.

```ts
// Direct control - WE call Client and IT calls Service
class Service { }

class Client {
  constructor() {
    const service = new Service();
  }
}

const client = new Client();
```

```ts
// IOC with DI - WE call Service and then WE call Client
class Service {}

class Client {
  constructor(service) {
    const service = service;
  }
}

const service = new Service();
const client = new Client(service);
```

![](img/20220730180017.png)

***

**Dependency injection** (DI) generally means passing a dependent object as a parameter to a method, rather than having the method create the dependent object. This is often used to implement IOC.

Here we **rely on abstractions rather than concrete implementations.** Any implementation the meets the requirements (__implements__ some interface) can be passed as a parameter.

***

Direct flow with concrete instances **(BAD)**:

```ts
class User {
  // Concrete database - hard to change to Oracle everywhere if we needed
  database: PostgresDatabase;

  // No injection - virtually impossible to test as we can't easily mock the PostgresDatabase instance
  constructor() {
    // Concrete Database
    this.database = new PostgresDatabase();
  }

  async add(data: string) {
    this.database.persist(data);
  }
}


class PostgresDatabase {
  async persist(data: string) {
    console.log(`Postgres has inserted ${data}`);
  }
}

class OracleDatabase {
  async persist(data: string) {
    console.log(`Oracle has inserted ${data}`);
  }
}


const user = new User();
```

***

IOC with DI **(GOOD)**:

```ts
class User {
  // Abstract database
  database: Database;

  // Inject a dependency
  constructor(database: Database) {
    this.database = database;
  }

  async add(data: string) {
    this.database.persist(data);
  }
}


interface Database {
  persist: (data: string) => void;
}

class PostgresDatabase implements Database {
  async persist(data: string) {
    console.log(`Postgres has inserted ${data}`);
  }
}

class OracleDatabase implements Database {
  async persist(data: string) {
    console.log(`Oracle has inserted ${data}`);
  }
}


const postgres = new PostgresDatabase():
const user = new User(postgres);
```

***

## Intro

### Install & Run

```bash
npm i -g @nestjs/cli

nest new test
``` 

You can generate entities:

```bash
# Help
nest generate --help

# Controller
nest generate controller products
nest g co products

# Services
nest g s products
```

***


## Entities

- **Modules**
  - `nest g mo module_name`
  - wrapped in `@Module()` wrapper
  - contain metadata that is used to organize the app structure
  - connect controllers and services to each other and other modules
- **Controllers**
  - `nest g co controller_name`
  - wrapped in `@Controller()` wrapper
  - manage routing and set certain parameters
  - call Services to handle requests
- **Services** 
  - `nest g s service_name`
  - wrapped in `@Injectable()` wrapper
  - store all the logic
  - if you want to use them in other modules, you need to **inject** them in the `constructor` (see further)

Example of a typical feature structure:

![](img/2021-10-02-20-12-35.png)

***

### Modules

#### Intro

`@Module({})` decorator takes a single object whose properties descibe the module:

- `imports` - an array of Modules that you import. Their providers (Services) will be automatically available in the current module once you **inject** them in Services.
- `controllers` - Controller(-s) of the current module (if any)
- `providers` - Services of the current module. Services of other modules that you already mentioned in `imports` are already available - no need to mention them here.
- `exports` - providers (Services) of this Module that should be available (public) in other modules that import this Module. 

Modules are **singletons** by default, so the same instance can be shared between modules effortlessly.

Example `cats.module`:

```ts
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  imports: [
    ConfigModule,
    JwtModule,
  ]
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService]
})
export class CatsModule {}
```

Now every module that imported `CatsModule`, has access to `CatsService`. 

***

#### Global modules

You need to import them in the `app.module` once, and they will be accessible throughout the app:

- either `@Global` decorator for regular Modules
- or `global: true` field in dynamic Modules

```ts
@Global
@Module({
  controllers: [MyModuleController],
  providers: [MyModuleService],
  exports: [MyModuleService],
})
export class MyModule {}
```

***

#### Dynamic modules

Classes that have **static methods** that return the same object with `providers`, `exports`, etc. 

By convention, methods are often called: 

- `forRoot` - global ones
- `forFeature` - local ones

```ts
// database.module
import { Module, DynamicModule } from '@nestjs/common';
import { createDatabaseProviders } from './database.providers';
import { Connection } from './connection.provider';

@Module({
  providers: [Connection],
})
export class DatabaseModule {
  static forRoot(entities = [], options?): DynamicModule {
    const providers = createDatabaseProviders(options, entities);
    return {
      module: DatabaseModule,
      providers: providers,
      exports: providers,
    };
  }
}

// app.module
@Module({
  imports: [
    DatabaseModule.forRoot([UserEntity]),
  ]
})
```

***

### Providers

Providers **inject dependencies**. In practice, these are Services, Factories, Repositories etc. 

Use `private` shorthand from TypeScript in the `constructor` to both **declare** and **initialize** your providers.

```ts
@Controller('coffee')
export class CoffeeController {
  constructor(
    private readonly coffeeService: CoffeeService,
  ) { }

  // ...
}
```

Nest resolves dependencies by their **types** (injects the instance of `CoffeeService` in the example above).

***

There're 4 types of them (F12 to `providers` and then `Provider` to see all of them):

- `useClass`
- `useFactory`
- `useValue`
- `useExisting` - use the existing provider under an alias

#### `useClass`

This notation

```ts
@Module({
  providers: [AppService],
})
export class AppModule {}
```

... is a full equivalent of this

```ts
@Module({
  providers: [{
    provide: AppService,
    useClass: AppService,
  }],
})
export class AppModule {}
```

#### `useValue`

Can be useful for mocking:

Try changing this

```ts
@Module({
  controllers: [ProductsController],
  providers: [ProductsService],
})
export class ProductsModule {}
```

... to this: 

```ts
@Module({
  controllers: [ProductsController],
  providers: [{
    provide: ProductsService,
    useValue: {
      getAll() {
        return 'mocked getAll';
      }
    },
  }],
})
export class ProductsModule {}
```

#### `useFactory`

Useful when we want to provide a service with some arguments attached (e.g. configs).

```ts
providers: [
  {
    useFactory: (configService: ConfigService) => { // The factory function that should return an instance of a Service or other provider
      const sendGridOptions = configService.get<ISendgridOptions>('sendgrid');
      if (!sendGridOptions) {
        throw new Error("Couldn't load Sendgrid configs");
      }
      return new SendGridService(sendGridOptions);
    },
    provide: SendGridService, // The name of the provider that will be used in the outside world
    inject: [ConfigService],  // Arguments for the factory function above
  },
],
```

#### `useExisting`

Provides new name for an existing Provider.

```ts
provider: [{
  provide: 'SecondServiceName',
  useExisting: ProductsService,
}]
```

***

### Controllers

You need to **inject** Providers (Services) into the `constructor` of your controllers. 

Nest uses **types** (or alternatively - strings and Symbols) to recognize what to inject. 

```ts
@Controller('products')
export class ProductsController {
  constructor(
    private readonly productsService: ProductsService,  // type says Nest what to inject
  ) { }

  // ...
}
```

Alternatively, you can use **strings**:

```ts
@Module({
  controllers: [ProductController],
  providers: [{
    provide: 'products-service',
    useClass: ProductsService,
  }],
})
export class ProductsModule {}
```

```ts
@Controller('products')
export class ProductsController {
  constructor(
    @Inject('products-service') private productsService: any, // any works now because Nest uses the string to recognize the service
  ) { }

  // ...
}
```

***

### Scope

Nest has 3 [scopes](https://docs.nestjs.com/fundamentals/injection-scopes#injection-scopes):

- `DEFAULT` - Singleton. A single instance of the provider is shared across the entire application. All singleton providers are instantiated once the app bootstraps. 
- `REQUEST` - A new instance of the provider is created exclusively for each incoming request. The instance is garbage-collected after the request has completed processing.
- `TRANSIENT` - Each consumer that injects a transient provider will receive a new, dedicated instance.

**Local storage** is a good example of when to use a different Scope: each user needs to use its own instance of it, local storage should not be shared among all users. 

Another good example is a **chainable class**. It should be `REQUEST` to not create conflicts during chaining when different users send their requests. 

```ts
import { Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class LocalStorageService {}
```

And for custom providers:

```ts
{
  provide: 'CACHE_MANAGER',
  useClass: CacheManager,
  scope: Scope.TRANSIENT,
}
```

When you apply Scope to a Controller, you actually apply it all its handler methods. 

```ts
@Controller({
  path: 'cats',
  scope: Scope.REQUEST,
})
export class CatsController {}
```

***

Imagine the following dependency graph: `CatsController <- CatsService <- CatsRepository`.

If `CatsService` is defined as `REQUEST`-scoped, `CatsController` that depends on it, will also become one. `CatsRepository` will remain `DEFAULT` as it doesn't depend on Services that use it. 

***


## Other concepts

### DTO

**Data Transfer Object** is and object used to encapsulate data and send it from one application to another.

It helps us define input and output interfaces.

***

### Pipes

#### Intro

A [pipe](https://docs.nestjs.com/pipes#custom-pipes) is a class with the `@Injectable` decorator which `implements PipeTransform` interface.

Pipes have 2 use-cases:

- **transformation**: transform input data into the desired form (from string into number, from plain object into class, etc.)
- **validation**: pass the valid data through unchanged; throw an exception otherwise

Pipes operate on the **controller arguments**. The pipe is invoked just before the method invocation. 

If an **error** is thrown in the pipe, it's caught by the **exception filters** and **no controller is getting called**.

Nest comes with some out-of-the-box pipes (but you can also create your own ones):

- `ValidationPipe` (relies on `class-validator` and `class-transformer`)
- `ParseIntPipe`
- `ParseFloatPipe`
- `ParseBoolPipe`
- `ParseArrayPipe`
- `ParseUUIDPipe`
- `ParseEnumPipe`
- `DefaultValuePipe`
- `ParseFilePipe`

Some of them are clear transformation pipes (`ParseIntPipe`), others - validation pipes.

***

#### Binding pipes

To use a pipe, we need **to bind** an instance of the pipe class to the appropriate context.

There are several ways to do that:

1. Passing the pipe as an argument to the `@Body()`, `@Param()`, `@Query`() decorators.

```ts
import { Get, Param, ParseIntPipe } from '@nestjs/common';

@Get(':id')
async findOne(@Param('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
```

In the example above:

- either `typeof id === 'number'`
- or an exception is thrown before the handler is called

We can pass either **a class**, or **an instance** (which allows us to customiza behavior):

```ts
@Get(':id')
async findOne(@Param('id', new ParseIntPipe({ errorHttpStatusCode: HttpStatus.GONE })) id: number) {
  return this.catsService.findOne(id);
}
```

1. Using `@UsePipes()` decorator of the controller (applied for all handlers on that controller) or individual controller handlers.

```ts
export class CreateCoffeeDto {
  @IsString()
  @IsNotEmpty()
  readonly name: string;

  @IsString()
  @IsNotEmpty()
  readonly brand: string;

  // 
}

@Post()
@UsePipes(ValidationPipe)
create(@Body() createCoffeeDto: CreateCoffeeDto) {
  return createCoffeeDto;
}
```

***

#### Custom pipes

Any pipe should `implement PipeTransform`:

```ts
import { ArgumentMetadata, Injectable, PipeTransform } from '@nestjs/common';

@Injectable()
export class CustomValidationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    // Place your validation/sanitization logic here
    return value;
  }
}
```

`PipeTransform` interface has 2 arguments:

- `value` - currently processed controller's argument
- `metadata` - its metadata

The `metadata` object has such properties:

```ts
export interface ArgumentMetadata {
  // @Body(), @Query(), @Param()
  type: 'body' | 'query' | 'param' | 'custom';
  // CreateCoffeeDto | undefined
  metatype?: Type<unknown>;
  // `id` for `update(@Param('id') coffeeId: string)` | undefined 
  data?: string;
}
```



***


## Middleware

Middleware is **unaware of the execution context**, including the handler that will be called and any of its parameters.

